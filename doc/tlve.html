<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>tlve</title>

<meta name="description" content="tlve">
<meta name="keywords" content="tlve">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body {
	margin: 1%;
	padding: 0 5%;
	background: white;
	font-family: serif;
	text-align: justify;
}

h1,h2,h3,h4,h5 {
    padding: 0.5em 0 0 0;
    font-weight: bold;
    font-family: sans-serif;
}

h1 {
    padding: 0.5em 0 0.5em 1em;
    color: inherit;
    background: #578;
}

pre {
  margin: 0;
  padding: 0.5em 0.5em 0.5em 0;
}

pre.example {
  padding: 0;
  margin: 0;
  background: #eee;
}

pre.verbatim, .menu {
  border: solid 1px gray;
  background: inherit;
  padding-bottom: 1em;
}

div.node {
  background: #ccc;
  margin: 0;
  padding: 0 1.5em;
  font-weight: lighter;
  color: #000;
  text-align: right;
}

.node a {
  color: #770000;
}

.node a:visited {
  color: #550000;
}

dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}

samp {
	font: inherit;
}

code {
	font-size: inherit;
    font-weight: bold;
}

pre, code { 
	font-family: monospace;
}

.command, .file {
   font-family: monospace;
} 

div.node hr {
    display:none;
}

-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">tlve</h1>





<a name="Top"></a>
<h1 class="node-heading">Top</h1>




<hr>
<a name="Overview"></a>
<a name="Overview-1"></a>
<h2 class="chapter">1 Overview</h2>
<a name="index-greetings"></a>
<a name="index-overview"></a>

<p>The <code>tlve</code> program is a command-line tool for parsing different
<acronym title="tag-length-value">tlv</acronym> (tag-length-value) structures and for printing them in various text-based formats.
In order to correctly parse the input data <code>tlve</code> uses a text-based configuration.
Default configuration file is <samp>~/.tlverc</samp> (<samp>tlve.rc</samp> in windows).
</p>
<p><code>tlve</code> can parse text or binary (including ASN.1 BER) tlv structures. Tag, length and value can have 
fixed length or separated format. Values can be presented in different formats and converted to different encoding.
</p>
<p><code>tlve</code> was written by Timo Savinen.
</p>
<p>This file documents version 2.3 of <code>tlve</code>.
</p>
<hr>
<a name="Sample"></a>
<a name="Sample-Output"></a>
<h2 class="chapter">2 Sample Output</h2>
<a name="index-sample"></a>

<p>Here are some realistic examples of running <code>tlve</code>.
</p>
<p>This is the output of the command &lsquo;<samp>cat&nbsp;ber.rc</samp>&rsquo;<!-- /@w -->:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">$cat ber.rc
# ASN.1 ber example configuration.
# This file is for reading any ASN.1 BER encoded file, this
# example contains names only for Universal class tags, add your
# own tags using tlv-keyword

#  test this by command:
#  tlve -c ber.tlverc -s BER &lt;inputfile&gt;
# or
#  tlve -c ber.tlverc -s BER -p dump &lt;inputfile&gt;

tl name=asn1ber tag=ber length=ber

structure name=BER content-tl=asn1ber
tlv name=Boolean tag=&quot;U-1&quot; value-type=uint
tlv name=Integer tag=&quot;U-2&quot; value-type=int
tlv name=BitString tag=&quot;U-3&quot; maybe-constructed=yes  value-type=bit-string
tlv name=OctetString tag=&quot;U-4&quot; maybe-constructed=yes value-type=hex
tlv name=NULL tag=&quot;U-5&quot; value-type=hex
tlv name=ObjectIdentifier tag=&quot;U-6&quot; value-type=oid
tlv name=ObjectDescriptor tag=&quot;U-7&quot; value-type=hex
tlv name=External tag=&quot;U-8&quot; 
tlv name=Real tag=&quot;U-9&quot; value-type=hex
tlv name=Enumerated tag=&quot;U-10&quot; value-type=int
tlv name=EmbeddedPvd tag=&quot;U-11&quot; value-type=hex
tlv name=UTF8String tag=&quot;U-12&quot; maybe-constructed=yes value-type=string encoding=UTF8
tlv name=RelativeOid tag=&quot;U-13&quot; value-type=hex
tlv name=Sequence tag=&quot;U-16&quot; 
tlv name=Set tag=&quot;U-17&quot; 
tlv name=NumericString tag=&quot;U-18&quot; value-type=string 
tlv name=PrintableString tag=&quot;U-19&quot; value-type=string 
tlv name=T61String tag=&quot;U-20&quot; value-type=string 
tlv name=VideotexString tag=&quot;U-21&quot; value-type=string 
tlv name=IA5String tag=&quot;U-22&quot; value-type=string encoding=ISO646-FI    # change encoding to suit your needs
tlv name=UTCTime tag=&quot;U-23&quot; value-type=string 
tlv name=GeneralizedTime tag=&quot;U-24&quot; value-type=string 
tlv name=GraphicString tag=&quot;U-25&quot; value-type=string 
tlv name=VisibleString tag=&quot;U-26&quot; value-type=string 
tlv name=GeneralString tag=&quot;U-27&quot; value-type=string 
tlv name=UniversalString tag=&quot;U-28&quot; value-type=string 
tlv name=CharacterString tag=&quot;U-29&quot; value-type=string 
tlv name=BMPString tag=&quot;U-30&quot; value-type=string encoding=UCS-4
structure-end

# printing definitions
# XML produced using this may not be wellformed
print name=XML file-start=&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot; \
      value=&quot;&lt;%n&gt;%v&lt;/%n&gt;\n&quot; constructor=&quot;&lt;%n&gt;\n&quot; constructor-end=&quot;&lt;/%n&gt;\n&quot; encoding=&quot;ISO-8859-1&quot; indent=&quot;  &quot;

print name=dump file-start=&quot;--- File: %f ---\n\n&quot; value=&quot;%n=%v (tag: %d, value %D)\n&quot; constructor=&quot;%n (tag: %d)&lt;\n&quot; constructor-end=&quot;&gt;\n&quot; indent=&quot;  &quot;
</pre></div>
</td></tr></table>


<p>This is the first few lines from output of the command 
&lsquo;<samp>tlve&nbsp;<span class="nolinebreak">-c</span>&nbsp;ber.rc&nbsp;<span class="nolinebreak">-s</span>&nbsp;BER&nbsp;<span class="nolinebreak">-p</span>&nbsp;XML&nbsp;<span class="nolinebreak">/usr/share/beid/certs/beid-cert-government.der</span></samp>&rsquo;<!-- /@w -->:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">$tlve -c ber.rc -s BER -p XML  /usr/share/beid/certs/beid-cert-government.der
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;Sequence&gt;
 &lt;Sequence&gt;
  &lt;[C-0]&gt;
   &lt;Integer&gt;2&lt;/Integer&gt;
  &lt;/[C-0]&gt;
  &lt;Integer&gt;4408622999086524144&lt;/Integer&gt;
  &lt;Sequence&gt;
   &lt;ObjectIdentifier&gt;1 2 840 113549 1 1 5&lt;/ObjectIdentifier&gt;
   &lt;NULL&gt;&lt;/NULL&gt;
  &lt;/Sequence&gt;
  &lt;Sequence&gt;
   &lt;Set&gt;
    &lt;Sequence&gt;
     &lt;ObjectIdentifier&gt;2 5 4 6&lt;/ObjectIdentifier&gt;
     &lt;PrintableString&gt;BE&lt;/PrintableString&gt;
    &lt;/Sequence&gt;
   &lt;/Set&gt;
   &lt;Set&gt;
    &lt;Sequence&gt;
     &lt;ObjectIdentifier&gt;2 5 4 3&lt;/ObjectIdentifier&gt;
     &lt;PrintableString&gt;Belgium Root CA&lt;/PrintableString&gt;
    &lt;/Sequence&gt;
   &lt;/Set&gt;
  &lt;/Sequence&gt;
  &lt;Sequence&gt;
   &lt;UTCTime&gt;030127000000Z&lt;/UTCTime&gt;
   &lt;UTCTime&gt;090127000000Z&lt;/UTCTime&gt;
  &lt;/Sequence&gt;
  .
  .
  .
</pre></div>
</td></tr></table>
<p>In this example an ASN.1 DER coded certificate was converted to XML.
</p>
<hr>
<a name="Invoking-tlve"></a>
<a name="Invoking-tlve-1"></a>
<h2 class="chapter">3 Invoking <code>tlve</code></h2>
<a name="index-invoking"></a>
<a name="index-version"></a>
<a name="index-options"></a>
<a name="index-usage"></a>
<a name="index-help"></a>
<a name="index-getting-help"></a>

<p>The format for running the <code>tlve</code> program is:
</p>
<div class="example">
<pre class="example">tlve <var>option</var> &hellip; <var>file</var> &hellip;
</pre></div>

<p><code>tlve</code> supports the following options:
</p>
<dl compact="compact">
<dt><code>--configuration=<var>name</var></code></dt>
<dt><code>-c <var>name</var></code></dt>
<dd><p>Read configuration from <var>name</var> instead of ~/.tlverc.
</p>
</dd>
<dt><code>--debug</code></dt>
<dt><code>-d</code></dt>
<dd><p>Dump unprocessable data to <samp>tlve.debug</samp>.
</p>
</dd>
<dt><code>--name-list=<var>list</var></code></dt>
<dt><code>-n</code></dt>
<dd><p>Print only elements having name or tag in comma separated list <var>list</var>. <code>tlve</code> recognises
the name if it is given with keyword <code>tlv</code> in configuration file. A tag must be enclosed in <code>[ ]</code>.
</p>
</dd>
<dt><code>--structure=<var>name</var></code></dt>
<dt><code>-s</code></dt>
<dd><p>The input data is processed using structure information <var>name</var>. If not given <code>tlve</code> uses structure named
as <code>default</code>.
</p>
</dd>
<dt><code>--expression <var>name</var>=<var>value</var></code></dt>
<dt><code>-e</code></dt>
<dd><p>Expression can be used to select blocks of elements. 
A block can be defined by by option <samp>-l,--start-level</samp> and/or <samp>-n,--name</samp>. 
If <samp>-l</samp> or <samp>-n</samp> is not given, only names appearing in this option are printed. 
A block is printed if any of given expression evaluates true.
</p>
<p><var>name</var> is name of a primitive element and the expression evaluates true if the contents of the element matches the regular expression in <var>value</var>.
</p>
</dd>
<dt><code>--and</code></dt>
<dt><code>-a</code></dt>
<dd><p>As default multiple expressions are combined with logical or. If this option is given multiple expressions are combined with logical and.
</p>
</dd>
<dt><code>--print=<var>name</var></code></dt>
<dt><code>-p</code></dt>
<dd><p>Output is formatted using printing definition <var>name</var>. Default is to use printing definition named as <code>default</code>.
</p>
</dd>
<dt><code>--output=<var>name</var></code></dt>
<dt><code>-o <var>name</var></code></dt>
<dd><p>Write output to <var>name</var> instead of standard output.
</p>
</dd>
<dt><code>--start-level=<var>level</var></code></dt>
<dt><code>-l <var>level</var></code></dt>
<dd><p>Only elements which are in level <var>level</var> or lower in element hierarchy are printed.  First (highest) level is level number one.  
</p>
<p>If <samp>-e, --expression</samp> is used with this option and 
the expression(s) in level <var>level</var> or in lower levels evaluates true, then all elements in <var>level</var> 
or lower levels are printed in that particular hierarchy.
</p>
<p>If both this option and <samp>-n, --name</samp> are defined, only names which appear in <var>level</var> or lower levels are printed.
</p>
</dd>
<dt><code>--stop-level=<var>level</var></code></dt>
<dt><code>-L <var>level</var></code></dt>
<dd><p>Only elements which are in level <var>level</var> or higher in element hierarchy are printed.  First level is level number one.  
</p>
<p>If both this option and <samp>-n, --name</samp> are defined, only names which appear in level <var>level</var> or higher in element hierarchy are printed.
</p>
</dd>
<dt><code>--help</code></dt>
<dt><code>-?</code></dt>
<dd><p>Print an informative help message describing the options and then exit
successfully.
</p>
</dd>
<dt><code>--version</code></dt>
<dt><code>-V</code></dt>
<dd><p>Print the version number of <code>tlve</code> on the standard output
and then exit successfully.
</p></dd>
</dl>
<p>All remaining options are names of input files, if no input files
are specified or &rsquo;-&rsquo; is given, then the standard input is read.
</p>
<hr>
<a name="Configuration"></a>
<a name="Configure-tlve"></a>
<h2 class="chapter">4 Configure tlve</h2>
<a name="index-configuration"></a>
<p><code>tlve</code> uses a text-based configuration file to process and print input data. Default configuration file
is <samp>~/.tlverc</samp>. Configuration is made up of keywords and parameter-value pairs. Comments start with <code>#</code>-character.
</p>
<p>Following chapters explain keywords and their meanings.
</p><a name="tl-_0028tag_002dlength_0029"></a>
<h4 class="subheading">tl (tag-length)</h4>
<p><code>tl name=<var>string</var> tag=<var>type</var>,<var>length</var>,<var>mask</var>,<var>shift</var>,<var>offset</var> 
type=<var>type</var>,<var>length</var>,<var>mask</var>,<var>shift</var>,<var>offset</var>
length=<var>type</var>,<var>length</var>,<var>mask</var>,<var>shift</var>,<var>offset</var>
print=<var>name</var> value-term=<var>string</var> tl-included=yes|no type-map=<var>name</var></code>
<br>
<br>
<code>tl</code> is used to specify characteristics of tag-length pair, which is used to parse a tlv file. Parameters and their meanings:
</p><dl compact="compact">
<dt><code>name=<var>string</var></code></dt>
<dd><p>Name of this definition, this is used when this definition is referred in other parts of the configuration.
</p>
</dd>
<dt><code>tag=<var>type</var>,<var>length</var>,<var>mask</var>,<var>shift</var>,<var>offset</var></code></dt>
<dd><p>Characteristics of tag. Typically a tag is defined by its <var>type</var> (integer, printable string,...) and its <var>length</var>.
</p><dl compact="compact">
<dt><code>type</code></dt>
<dd><p>Can be any of following: 
</p><dl compact="compact">
<dt><code>int</code></dt>
<dt><code>int-be</code></dt>
<dd><p>Signed integer, big endian.
</p></dd>
<dt><code>int-le</code></dt>
<dd><p>Signed integer, little endian.
</p></dd>
<dt><code>uint</code></dt>
<dt><code>uint-be</code></dt>
<dd><p>Unsigned integer, big endian.
</p></dd>
<dt><code>uint-le</code></dt>
<dd><p>Unsigned integer, little endian.
</p></dd>
<dt><code>string</code></dt>
<dd><p>Printable string.
</p></dd>
<dt><code>ber</code></dt>
<dd><p>ASN.1 BER encoded tag.
</p></dd>
</dl>
</dd>
<dt><code>length</code></dt>
<dd><p>The length of the tag as a decimal integer. 
If the tag and length are separated the separator character can be given in 
format <var>/c/</var> where <var>c</var> is the character separating tag and length.
</p></dd>
<dt><code>mask</code></dt>
<dd><p>An integer tag is and-masked with this value. Mask can be given as decimal or hexadecimal integer. Hexadecimal values
are given as <code>0xnn</code>. Value zero will not be used.
</p></dd>
<dt><code>shift</code></dt>
<dd><p>An integer tag is bit shifted using this value. If <code>shift</code> is positive, 
tag will be shifted left, if negative tag will be shifted right.
</p></dd>
<dt><code>offset</code></dt>
<dd><p>As default the tag is assumed to be in offset 0 of a tlv triplet. if <code>offset</code> is given, tag will be read
from position specified by this offset.
</p></dd>
</dl>
<p>Only the <code>type</code> and <code>length</code> or <code>value-term</code> are mandatory, all other values are optional. 
</p>
</dd>
<dt><code>type=<var>type</var>,<var>length</var>,<var>mask</var>,<var>shift</var>,<var>offset</var></code></dt>
<dd><p>If input data contains value encoding information, it can be read using this definition. Input types can be mapped to internal value types using <code>typemap</code>.
</p><dl compact="compact">
<dt><code>type</code></dt>
<dd><p>Can be any of following. <strong>Note</strong>: Integers are always read as unsigned.
</p><dl compact="compact">
<dt><code>int</code></dt>
<dt><code>int-be</code></dt>
<dd><p>Signed integer, big endian.
</p></dd>
<dt><code>int-le</code></dt>
<dd><p>Signed integer, little endian.
</p></dd>
<dt><code>uint</code></dt>
<dd><p>Unsigned integer, big endian.
</p></dd>
<dt><code>uint-be</code></dt>
<dt><code>uint-le</code></dt>
<dd><p>Unsigned integer, little endian.
</p></dd>
<dt><code>string</code></dt>
<dd><p>Printable string.
</p></dd>
<dt><code>ber</code></dt>
<dd><p>ASN.1 BER encoded length.
</p></dd>
</dl>
</dd>
<dt><code>length</code></dt>
<dd><p>The length of the type part of a tlv triplet. If the type and the length are separated, 
the separator character can be given as <var>/c/</var> where <var>c</var> is the character separating the type and the length.
</p></dd>
<dt><code>mask</code></dt>
<dd><p>The type is and-masked with this value. Mask can be given as decimal or hexadecimal integer. Hexadecimal values
are given as <code>0xnn</code>. Value zero is not used.
</p></dd>
<dt><code>shift</code></dt>
<dd><p>The type it is bit shifted using this value. If <code>shift</code> is positive, 
type will be shifted left, if negative type will be shifted right.
</p></dd>
<dt><code>offset</code></dt>
<dd><p>As default the type is assumed to be positioned right after the tag, If this parameter is given type is read using this offset. 
<strong>Note</strong>: Offset is relative to the beginning of the tlv triplet, not relative to the end of the tag.
</p></dd>
</dl>
<p>Only the <code>type</code> is mandatory, all other values are optional.
</p>
</dd>
<dt><code>length=<var>type</var>,<var>length</var>,<var>mask</var>,<var>shift</var>,<var>offset</var></code></dt>
<dd><p>Characteristics of length. Typically a length is defined by its <var>type</var> (integer, printable string,...) and its <var>length</var>.
</p><dl compact="compact">
<dt><code>type</code></dt>
<dd><p>Can be any of following. <strong>Note</strong>: Integers are always read as unsigned.
</p><dl compact="compact">
<dt><code>int</code></dt>
<dt><code>int-be</code></dt>
<dd><p>Signed integer, big endian.
</p></dd>
<dt><code>int-le</code></dt>
<dd><p>Signed integer, little endian.
</p></dd>
<dt><code>uint</code></dt>
<dd><p>Unsigned integer, big endian.
</p></dd>
<dt><code>uint-be</code></dt>
<dt><code>uint-le</code></dt>
<dd><p>Unsigned integer, little endian.
</p></dd>
<dt><code>string</code></dt>
<dd><p>Printable string.
</p></dd>
<dt><code>ber</code></dt>
<dd><p>ASN.1 BER encoded length.
</p></dd>
</dl>
</dd>
<dt><code>length</code></dt>
<dd><p>The length of the length part of a tlv triplet. If the length and the value are separated, 
the separator character can be given as <var>/c/</var> where <var>c</var> is the character separating the length and value.
</p></dd>
<dt><code>mask</code></dt>
<dd><p>The length is and-masked with this value. Mask can be given as decimal or hexadecimal integer. Hexadecimal values
are given as <code>0xnn</code>. Value zero is not used.
</p></dd>
<dt><code>shift</code></dt>
<dd><p>The length it is bit shifted using this value. If <code>shift</code> is positive, 
length will be shifted left, if negative length will be shifted right.
</p></dd>
<dt><code>offset</code></dt>
<dd><p>As default the length is assumed to be positioned right after the tag (or type if defined), If this parameter is given length is read using this offset. 
<strong>Note</strong>: Offset is relative to the beginning of the tlv triplet, not relative to the end of the tag.
</p></dd>
</dl>
<p>Only the <code>type</code> is mandatory, all other values are optional.
</p>
</dd>
<dt><code>print=<var>name</var></code></dt>
<dd><p>Values read using this tag-length definition are printed using printing definition <var>name</var>.
</p>
</dd>
<dt><code>value-term=<var>string</var></code></dt>
<dd><p>The length will not be used. Instead the value is terminated by <var>string</var>. <var>string</var> is not considered as a part of the value. This parameter and <code>length</code> are mutually exclusive. 
</p>
</dd>
<dt><code>tl-included=yes|no</code></dt>
<dd><p>The tag-length part is included/not included in length. Default is value is no, meaning that the length contains only the length of the value part of tlv triplet.
</p></dd>
<dt><code>type-map=<var>name</var></code></dt>
<dd><p>Mapping of input data types to internal types is done using mappings in <code>typemap</code> definition <var>name</var>.
</p></dd>
</dl>

<a name="typemap"></a>
<h4 class="subheading">typemap</h4>
<p><code>
typemap name=<var>string</var> <br>
map &hellip; <br>
map &hellip; <br>
map &hellip; <br>
. <br>
. <br>
. <br>
typemap-end
</code>
<br>
<br>
</p><dl compact="compact">
<dt><code>name=<var>string</var></code></dt>
<dd><p>The name of a typemap. This name is used when referring to this item in other parts of configuration
</p></dd>
</dl>
<p><code>typemap</code> is used to map input value types to tlve&rsquo;s internal value types. Input value type can be defined in <code>tl</code> with keyword <code>type</code>.
<code>map</code> keyword has two parameters:<br><br>
<code>map value=<var>string</var> <span class="nolinebreak">value-type=int|int-be|int-le|uint|uint-be|uint-le|string|hex|hexs|dec|bcd|bcds|oid|bit-string|escaped</span><!-- /@w --></code>
</p><dl compact="compact">
<dt><code>value=<var>string</var></code></dt>
<dd><p>If <var>string</var> is found as input data type it is mapped to internal value type defined by parameter <var>value-type</var>.
</p></dd>
<dt><code>value-type=int|int-be|int-le|uint|uint-be|uint-le|string|hex|hexs|dec|bcd|bcds|oid|bit-string|escaped</code></dt>
<dd><p>This value is used in formatting the value for printing. See the meanings of different value types in next chapter.
</p></dd>
</dl>

<a name="tlv-_0028tag_002dlength_002dvalue_0029"></a>
<h4 class="subheading">tlv (tag-length-value)</h4>
<p><code>tlv name=<var>string</var> tag=<var>string</var> end-tag=<var>string</var>  path=<var>string</var> type=constructed|primitive|end-of-content
<span class="nolinebreak">value-type=int|int-be|int-le|uint|uint-be|uint-le|string|hex|hexs|dec|bcd|bcds|oid|bit-string|escaped</span><!-- /@w -->
content-tl=<var>name</var> print=<var>name</var> encoding=<var>name</var>
form=definite|indefinite format=<var>string</var> value-length-adjust=<var>integer</var> maybe-constructed=yes|no hold=yes|no|<var>name</var></code> 
<br>
<br>
<code>tlv</code> is used to specify characteristics of one tlv triplet by mapping additional info to it using the parameter <code>tag</code> as a key.
<code>tlv</code> is only used inside the <code>structure</code> definition (see below). Parameters and their meanings:
</p><dl compact="compact">
<dt><code>name=<var>string</var></code></dt>
<dd><p>The name of a triplet. This name is used when referring to this item in other parts of configuration or in command line
(options <samp>-n, --name-list</samp> and <samp>-e, --espression</samp>). 
<var>string</var> is printed using the printing directive <code>%n</code>.
</p></dd>
<dt><code>tag=<var>string</var></code></dt>
<dd><p><var>string</var> is used as a key when mapping tlv triplet from input to this definition. ASN.1 BER tags are given in form <code>X-n</code> where
<code>X</code> is the class of tag: U,A,C or P for Universal, Application, Context-specific or Private type of BER-tag. <code>n</code> is decimal number.
</p></dd>
<dt><code>end-tag=<var>string</var></code></dt>
<dd><p>If given, the <var>string</var> from the parameter <code>tag</code> and <var>string</var> from this parameter are considered as value range when mapping 
tlv triplets to this definition.
</p></dd>
<dt><code>path=<var>string</var></code></dt>
<dd><p>Only tlv triplets which have path <var>string</var> are mapped to this definition. Path is dot separated list of constructor element names or tags
which are preceding this element in constructor hierarchy. If name is not given for a constructor the tag enclosed in <code>[ ]</code> is used. If path starts with asterisk (<code>*</code>) then only the rest of the path must match with the current path.
</p></dd>
<dt><code>type=constructed|primitive|end-of-content</code></dt>
<dd><p>The role of this element in tlv hierarchy. 
</p><dl compact="compact">
<dt><code>constructed</code></dt>
<dd><p>Element contains one or several other elements, not a single value.
</p></dd>
<dt><code>primitive</code></dt>
<dd><p>Element  contains a single value, this is the default type.
</p></dd>
<dt><code>end-of-content</code></dt>
<dd><p>Elements role is to indicate the end of constructed data. This is normally used when constructor has no given length.
These elements are not printed.
</p></dd>
</dl>
</dd>
<dt><code>value-type=int|int-be|int-le|uint|uint-be|uint-le|string|hex|hexs|dec|bcd|bcds|oid|bit-string|escaped</code></dt>
<dd><p>Type of the value. Default is to use value type from <code>typemap</code> or if that is not used then <code>escaped</code> is used.
</p><dl compact="compact">
<dt><code>int</code></dt>
<dt><code>int-be</code></dt>
<dd><p>Big endian signed integer.
</p></dd>
<dt><code>int-le</code></dt>
<dd><p>Little endian signed integer.
</p></dd>
<dt><code>uint</code></dt>
<dt><code>uint-be</code></dt>
<dd><p>Big endian unsigned integer.
</p></dd>
<dt><code>uint-le</code></dt>
<dd><p>Little endian unsigned integer.
</p></dd>
<dt><code>string</code></dt>
<dd><p>Printable string. 
</p></dd>
<dt><code>hex</code></dt>
<dd><p>Value bytes are printed as hexadecimal numbers.
</p></dd>
<dt><code>hexs</code></dt>
<dd><p>Value bytes are printed  as hexadecimal numbers with half bytes swapped.
</p></dd>
<dt><code>dec</code></dt>
<dd><p>Value bytes are printed as space separated decimal numbers
</p></dd>
<dt><code>bcd</code></dt>
<dd><p>Value contains a bcd number.
</p></dd>
<dt><code>bcds</code></dt>
<dd><p>Value contains a bcd number with half bytes swapped.
</p></dd>
<dt><code>oid</code></dt>
<dd><p>Value contains an ASN.1 object identifier. Sub-identifiers are printed as space separated decimal values. 
</p></dd>
<dt><code>bit-string</code></dt>
<dd><p>Value bits are printed in groups of eight. For non ASN.1 data all bytes are printed. For ASN.1 bit-string
the first byte contains the number of non printable bits of the last byte and it is not printed.
</p></dd>
<dt><code>escaped</code></dt>
<dd><p>Value is printed as string, except non printable characters are printed as <code>\xnn</code>, where <code>nn</code> is the hexadecimal value of a character.
</p></dd>
</dl>
</dd>
<dt><code>content-tl=<var>name</var></code></dt>
<dd><p>Valid for constructor type elements only. tlv triplets inside this constructor are read using tl definition <var>name</var>.
This makes it possible to a single file have different tlv encoding in different levels of constructor hierarchy.
</p></dd>
<dt><code>print=<var>name</var></code></dt>
<dd><p>Printing is done according printing definition <var>name</var>.
</p></dd>
<dt><code>encoding=<var>name</var></code></dt>
<dd><p>The value part of tlv triplet has encoding <var>name</var>. Before printing the value (printing directive <code>%v</code>) the contents
of the value is converted to system encoding (default) or encoding specified in printing definition. For more information about
encoding see &lsquo;<samp>man&nbsp;iconv</samp>&rsquo;<!-- /@w -->.
</p></dd>
<dt><code>form=definite|indefinite</code></dt>
<dd><p>Valid for constructor type elements only:
</p><dl compact="compact">
<dt><code>definite</code></dt>
<dd><p>Use constructor elements length to detect the end of constructed content.
</p></dd>
<dt><code>indefinite</code></dt>
<dd><p>Constructed element ends when a end-of-content element is found. 
</p></dd>
</dl>
</dd>
<dt><code>format=<var>string</var></code></dt>
<dd><p><var>string</var> is a printf-style printing directive for integer values. Integers are handled as 
<code>long long int</code> and the default formats are  <code>%lli</code> and  <code>%llu</code>.
If <var>string</var> starts with <code>+</code> or <code>++</code> the rest of the <var>string</var> is considered as
format string for <code>strftime()</code> function and the value is considered to be UNIX time. If single <code>+</code>
is given time is formatted as local time, if <code>++</code> is given the time is formatted as UTC time.
</p></dd>
<dt><code>value-length-adjust=<var>integer</var></code></dt>
<dd><p>Before reading the value from input, the length of the value is adjusted as <code>length = length + <var>integer</var></code>.
<var>integer</var> can be negative allowing reading less data as expressed by the length in tl data.
<strong>Note</strong>: length consumed by the tlv triplet is not affected by this parameter.
</p></dd>
<dt><code>maybe-constructed=yes|no</code></dt>
<dd><p>If an element is a primitive type by default and this is set as <code>yes</code>, then <code>tlve</code> first checks 
if the beginning of the value is a valid tl pair and the tl pair&rsquo;s length added to the length expressed 
by the tl pair matches the total length of this element. If this is true the element is treated as a constructed
element. Default is <code>no</code>.
</p></dd>
<dt><code>hold=yes|no|<var>name</var></code></dt>
<dd><p>If <code>yes</code> or <var>name</var> the value part of a primitive element or the name of a constructed element is put in hold. 
The value in hold can be printed using notation <code>$</code><var>name</var>, where <var>name</var> is
the name of the tlv triplet or an alias name given by <var>name</var>. Only the latest value encountered is saved. Several
different elements can share the same alias name.
This can be used to save the value or the name for later printing. Default is no.
</p></dd>
</dl>
<p>Only parameters <code>name</code> and <code>tag</code> are mandatory.
</p>    
<a name="structure"></a>
<h4 class="subheading">structure</h4>
<p>Structure is a multi-line configuration element, which specifies basic characteristics of a tlv input file. 
Structure can contain multiple <code>tlv</code> keywords.
<br>
<code>
structure name=<var>name</var> content-tl=<var>name</var> print=<var>name</var> filler=<var>string</var> hex-caps=yes|no <br>
tlv &hellip; <br>
tlv &hellip; <br>
tlv &hellip; <br>
. <br>
. <br>
. <br>
structure-end
</code>
<br>
<br>
</p><dl compact="compact">
<dt><code>name=<var>name</var></code></dt>
<dd><p>A name for structure. This is the name which should be given with option <samp>-s, --structure</samp>.
</p></dd>
<dt><code>content-tl=<var>name</var></code></dt>
<dd><p>A name of a tl definition. tlv triplets are read using this information.
</p></dd>
<dt><code>print=<var>name</var></code></dt>
<dd><p>Elements in this structure are printed using printing definition <var>name</var>, default is to use printing definition named as &rsquo;default&rsquo;. 
This can be overridden using different names for <code>print</code> in <code>tl</code> or <code>tlv</code> keywords.
</p></dd>
<dt><code>filler=<var>string</var></code></dt>
<dd><p><var>string</var>s are skipped when reading the input. 
Non printable characters can be escaped as <code>\xnn</code>, where <code>nn</code> is characters hexadecimal value.
</p></dd>
<dt><code>hex-caps=yes|no</code></dt>
<dd><p>if set as <code>yes</code> then the hexadecimal values are printed in capital letters.
</p></dd>
</dl>
<p>After <code>structure</code> keyword there can be any number of <code>tlv</code> keywords, <code>structure</code> definition is
ended by <code>structure-end</code> keyword. Only parameters <code>name</code> and <code>content-tl</code> are mandatory.
</p>
<a name="print"></a>
<h4 class="subheading">print</h4>
<p>Keyword <code>print</code> specifies how to print tlv triplets in text-based formats.
<br>
<code>print name=<var>string</var> file-start=<var>string</var> file-end=<var>string</var> constructor=<var>string</var> 
constructor-end=<var>string</var> value=<var>string</var> indent=<var>string</var> encoding=<var>name</var>
block-start=<var>string</var> block-end=<var>string</var> separator=<var>char</var></code>
<br>
<br>
</p><dl compact="compact">
<dt><code>name=<var>string</var></code></dt>
<dd><p>A name for this printing definition. This name can be referred in other parts of the configuration or 
with option <samp>-p, --print</samp>.
</p></dd>
<dt><code>file-start=<var>string</var></code></dt>
<dd><p>Output <var>string</var> for every input file before processing the file.
</p></dd>
<dt><code>file-end=<var>string</var></code></dt>
<dd><p>Output <var>string</var> for every input file after processing the file.
</p></dd>
<dt><code>constructor=<var>string</var></code></dt>
<dd><p><var>string</var> is printed when a constructor type element is encountered.
</p></dd>
<dt><code>constructor-end=<var>string</var></code></dt>
<dd><p><var>string</var> is printed after the last element of a constructor type element has been printed.
</p></dd>
<dt><code>value=<var>string</var></code></dt>
<dd><p><var>string</var> is printed for each primitive tlv triplet
</p></dd>
<dt><code>indent=<var>string</var></code></dt>
<dd><p><var>string</var> is printed <var>n</var> times  before any other data.
<var>n</var> is the depth of the constructor hierarchy. Default is not to indent.
</p></dd>
<dt><code>encoding=<var>name</var></code></dt>
<dd><p>If the value to be printed has a <code>encoding</code> parameter in <code>tlv</code>, the <var>name</var>
is used as target encoding. Default is to used system encoding (which can be checked by <code>tlve -V</code>).
</p></dd>
<dt><code>block-start=<var>string</var></code></dt>
<dd><p><var>string</var> is printed before a group of elements found using expression (<samp>-e,--expression</samp>) 
and/or start level (<samp>-l,--start-level</samp>) is printed. <strong>Note</strong>: <var>string</var> is not printed
if group of elements found is empty.
</p></dd>
<dt><code>block-end=<var>string</var></code></dt>
<dd><p><var>string</var> is printed after a group of elements found using expression (<samp>-e,--expression</samp>)
and/or start level (<samp>-l,--start-level</samp>) is printed. <strong>Note</strong>: <var>string</var> is not printed
if group of elements found is empty.
</p></dd>
<dt><code>separator=<var>char</var></code></dt>
<dd><p><var>char</var> is printed after every primitive element except the last one in a group of elements 
found using expression (<samp>-e,--expression</samp>) and/or start level (<samp>-l,--start-level</samp>).
</p></dd>
</dl>
<a name="printf_002dstyle-directives"></a>
<h4 class="subsubheading">printf-style directives</h4>
<p><var>string</var> used in parameters for <code>print</code> can contain following printf-style directives:
</p><dl compact="compact">
<dt><code>%%</code></dt>
<dd><p>Print single %.
</p></dd>
<dt><code>%$</code></dt>
<dd><p>Print single $.
</p></dd>
<dt><code>%&gt;</code></dt>
<dd><p>Print the current level of the element hierarchy, first (highest) level is 1.
</p></dd>
<dt><code>%l</code></dt>
<dd><p>Print the length of the value part of the tlv triplet.
</p></dd>
<dt><code>%c</code></dt>
<dd><p>Print the number of bytes consumed by the tlv triplet.
</p></dd>
<dt><code>%t</code></dt>
<dd><p>Print the tag of the tlv triplet.
</p></dd>
<dt><code>%n</code></dt>
<dd><p>Print the name (given by the <code>tlv</code> keyword) of the tlv triplet. If the tlv triplet cannot be associated with 
any of the <code>tlv</code> keywords in <code>structure</code> definition, then
the tag enclosed in <code>[ ]</code> is printed.
</p></dd>
<dt><code>%v</code></dt>
<dd><p>Print the value part of the tlv triplet. Before printing possible character set conversion is performed.
</p></dd>
<dt><code>%p</code></dt>
<dd><p>Current constructor path is printed. <strong>Note</strong>: This is not printed if option <samp>-e, --expression</samp> is used.
</p></dd>
<dt><code>%o</code></dt>
<dd><p>Print the current input file offset. Offset is the start of the current tlv triplet.
</p></dd>
<dt><code>%O</code></dt>
<dd><p>Print the total offset calculated for all input files. Offset is the start of the current tlv triplet.
</p></dd>
<dt><code>%f</code></dt>
<dd><p>Print the current file name.
</p></dd>
<dt><code>%s</code></dt>
<dd><p>Print the current structure name.
</p></dd>
<dt><code>%d</code></dt>
<dd><p>Print the hex dump of the tag-length part in format <code>xnnxnn&hellip;</code>. <code>nn</code> is the hexadecimal value
of an octet.
</p></dd>
<dt><code>%D</code></dt>
<dd><p>Print the hex dump of the value part in format <code>xnnxnn&hellip;</code>. <code>nn</code> is the hexadecimal value
of an octet.
</p></dd>
</dl>
<p><var>string</var> can also contain following escape codes:
<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\&quot;</code> and <code>\#</code>.
A backslash can be escaped as <code>\\</code>. If <var>string</var> contains white-space characters <var>string</var> must be 
enclosed in double quotation marks <code>&quot;</code>.
Non printable characters can be escaped as <code>\xnn</code>, where <code>nn</code> is characters hexadecimal value.
</p><a name="Hold-variables"></a>
<h4 class="subsubheading">Hold variables</h4>
<p>If elements is put in &quot;hold&quot; (parameter <var>hold</var> in tlv-keyword), 
then the value of a primitive element or the name of a constructed element can be printed in <var>string</var>s 
using notation
<br>
<br>
<code>$</code><var>name</var>
<br>
<br>
where the <var>name</var> is the name of the tlv triplet or the alias name. 
Tlve prints always the latest encountered value or name of the <var>name</var>. 
This can be used e.g. to save a value from the beginning of the file to be printed with later found elements.
</p><a name="Input-Preprocessor"></a>
<h4 class="subheading">Input Preprocessor</h4>
<p>It is possible to define an input preprosessor for <code>tlve</code>. An input preprocessor is simply an executable program
which writes the contents of the input file to standard output which will be read by <code>tlve</code>. If the input preprosessor
does not write any characters on its standard output, then <code>tlve</code> uses the original file.
</p>
<p>To set up an input preprocessor, set the <code>TLVEOPEN</code> environment variable to a command line which will invoke your input preprocessor.
This command line should include  one  occurrence  of  the string <code>%s</code>, which will be replaced by the input filename when the input preprocessor command is invoked.
</p>
<p>The input preprocessor is not used if <code>tlve</code> is reading standard input.
</p>
<p>Convenient way is to use <code>lesspipe</code> (or <code>lesspipe.sh</code>), which is availabe in many UNIX-systems, for example
<br>
</p><div class="example">
<pre class="example">export TLVEOPEN=&quot;/usr/bin/lesspipe %s&quot;
</pre></div>

<p>Using the example above is it possible to give a zipped input file to <code>tlve</code>, then the input processor will unzip the file before it is processed by <code>tlve</code>.
</p>
<hr>
<a name="Examples"></a>
<a name="How-to-use-tlve"></a>
<h2 class="chapter">5 How to use tlve</h2>
<a name="index-example"></a>
<p>Examples of rc-files can be found in <code>tlve</code> package.
</p>
<hr>
<a name="Problems"></a>
<a name="Reporting-Bugs"></a>
<h2 class="chapter">6 Reporting Bugs</h2>
<a name="index-bugs"></a>
<a name="index-problems"></a>

<p>If you find a bug in <code>tlve</code>, please send electronic mail to
<a href="mailto:tjsa@iki.fi">tjsa@iki.fi</a>.  Include the version number, which you can find by
running &lsquo;<samp>tlve&nbsp;<span class="nolinebreak">--version</span></samp>&rsquo;<!-- /@w -->.  Also include in your message the
output that the program produced and the output you expected.
</p>
<p>If you have other questions, comments or suggestions about
<code>tlve</code>, contact the author via electronic mail to
<a href="mailto:tjsa@iki.fi">tjsa@iki.fi</a>.  The author will try to help you out, although he
may not have time to fix your problems.
</p>
<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">
<ul class="no-bullet">
<li><a name="toc-Overview-1" href="#Overview">1 Overview</a></li>
<li><a name="toc-Sample-Output" href="#Sample">2 Sample Output</a></li>
<li><a name="toc-Invoking-tlve-1" href="#Invoking-tlve">3 Invoking <code>tlve</code></a></li>
<li><a name="toc-Configure-tlve" href="#Configuration">4 Configure tlve</a></li>
<li><a name="toc-How-to-use-tlve" href="#Examples">5 How to use tlve</a></li>
<li><a name="toc-Reporting-Bugs" href="#Problems">6 Reporting Bugs</a></li>

</ul>
</div>

<hr>



</body>
</html>
